# The REAL Legend of Zelda Remastered
#### Video Demo: https://youtu.be/sJVQa7eYm0g
#### Description: Hello World.  This is my final project for CS50x, The REAL Legend of Zelda Remastered.  I decided to make a javascript game for my final project, because I had made a game in Scratch called the REAL Legend of Zelda.  Scratch has a lot of limitations, and I wanted to make an updated version of the game that broke through those limitations.  And I think I very much succeeded in that endeavour.  

#### The game is made using HTML's canvas element and javascript for all of the logic and interactions.  The map was made in Tiled, and the sprites are free-use.  The music is from various Legend of Zelda games, and the game over music is from Final Fantasy 7.  The boundaries were also made in Tiled, and exported as data.  The data for the boundaries and the map are all in the data folder, the images for the sprites are all in the img folder, and the sounds and music are all in the sound folder.

#### index.js is where the main functions that run the game are.  It initializes three canvases that are stacked on top of eachother.  The first canvas is where most of the animations are.  The second canvas is for fading the screen or flashing it red when taking damage, and the third canvas is for the dialogue boxes.  It also initializes all the variables that are used in the game, which include, but are not limited to, the level counter, health, enemy health, timers, arrays for beam attacks, collision and boundary maps, enemy arrays.

#### As stated above, the collisions for the map were made in Tiled and exported as a json. I extracted the data for boundaries that I made in Tiled and put them in the js files in the data folder and then converted that array into a 2D array so that I could loop through the data correctly when checking for collisions.  i increases by increments of 85 because i is the number of tiles wide the map is in the program Tiled, so each row of the map is 85 tiles wide, so each row of the array will have 85 values in it.  Blank spaces are represented by 0 in the data arrays and the boundaries are represented by 2060, which refers to the light red I used to draw the boundaries in Tiled.  I then put all the 2060's into the boundaries array and set their position by multiplying their row and column position by 16, which is the size of each tile in Tiled.  The row number i represents the y position and the column number j represents the x position.

#### Credit to Chris Courses Pokemon JavaScript Game Tutorial for this method.  His tutorials helped a lot in getting me started on the foundation for this project.

#### The game is started by pressing the start button when the page is initially loaded.  The class for CanvasGame where the button sends the start call to is in its own canvas.js file instead of class.js for some reason.  Not sure why I did that to be honest.  It was one of the first things I did, so maybe that is why.

#### Anyways once the game starts, the openingScreen function is called, which triggers a fadein from black to the opening screen image.  There is that starts when the game starts, and the opening logo triggers once the openTimer hits 314.  ANd then at 360, the press Z to Start text appears afterwards.  I initially tried to use the built-in timer that all browsers have, but I found that if you stay on the page without pressing the button, the timer continues to go up, which then threw off the timing of everything afterwards.  And there was no way to control the built-in browser timer, so I made timers for everything.  Once you press Z to start the game the prologue function is called.  All of the text in the prologue is also timer based, and a different image is shown at a set interval based on the timer.  In this case the timer is called proTimer.  Once the prologue is finished level1() is called.  There is also a shortcut to bypass the prologue, if you press x.  This also calls level 1() and sets the level variable to 1 and dialogueNumber to 1.

#### The functions of the dialogue are kept in dialogue.js.  They are called by the level function, and to avoid any possible bugs they are controlled by their own unique dialogueNumber variable.  They also have a timer as part of their condition to go to the next dialogue to add a slight delay, so that dialogue boxes are not skipped by a single key press.

#### In the level function, requestAnimationFrame() is being continuously run with a set delay of 1000/fps.  I believe 1000 stands for 1000 milliseconds, and the FPS is set to 60, so that 60 frames per second are happening on the screen.  I can't confirm this is the case though because I've found that on the three computers I've run the game on, the timings of all the triggers have been different on each of them.  In anycase, if you do not do the setTimeout, requestAnimationFrame will run at the refresh rate of the monitor you are using.  I actually found out about this when I switched from a 60Hz monitor to a 144Hz monitor.  I found that the game ran over twice as fast on the 144Hz monitor, and so I found that you had to use setTimeout to make the game run more consistently across platforms and monitors.

#### Anyways the level function calls on the draw function of all the objects and sprites that are going to be used in the level, starting with the map.  The order in which the draw functions are called is very important.  As the draw functions that are called later overwrite the draw functions that are called earlier.  Therefore if the function drawing the map was called at the end, all you would see would be the map, and nothing else.

#### The prototype classes for the boundaries, and all of the sprites are held in class.js.  The prototypes include the Boundaries class, the Sprite class, the Enemy class, the Dialogues class, the Portal class, the triBeam class, and the ganonBeam class.  It also contains all of the functions for beam movement, and collision for some reason.  I think it was cause it made the process of creating these functions easier for me.  Not really sure why I did this instead of putting them in the functions.js file.  Anyways each of the classes have their own constructor function which contains all of their properties, and a draw function.  The way the draw function works is that it cycles through a frameCount that will have the game draw a different image at a set interval, which would create the illusion that the character is walking.  I wrote a comment for it in class.js that I think explains it a bit better than I did just now, but that's the gist of how it works.

#### Anyways back to index.js the level ends when you either lose all of your health, and get sent to the Game Over Screen, or you reach the chest at the end of the path.  If you lose all of your health, you are sent to the game over screen by the gameover() function which is in the functions.js file.  Upon pressing x the game will restart, and all of the variables will also be reset to their initial values, and you can start the game over again.  If you manage to reach the chest at the end then level2().  This will also have its own dialogue options, and will also include a new map, new enemy Keese, and the triBeam.  Each level calls the next level function, through the fadechest() function that each level has.  The fadechest() function also sets the level variable to the next level, and resets the position of Keese and the health of the various enemies, and the main characters own health.  Each level calls the function for the next level until you reach the end and are able to restart the game again.

#### Most of the functions of the game are in the functions.js file.  The alphaFade and alphaUnfade control the color and opacity of the cf canvas, which is usually an invisible canvas that is on top of the main c canvas.  These functions are what controls the fade in from black or fade out to white, or the red flashes when taking damage.  Similar logic is used for the dialogue canvas cd.  I don't know why, but working with canvas opacity was really frustrating, as sometimes the fade would work correctly, and other times the fade would just be instant.  I think in the end it came down to making sure the i variable used in the fade functions was set to the correct initial value each time the function was called.  But it was pretty frustrating, when I was troubleshooting this.

#### Below that are the collision and movement functions.  The collision function checks for the x position of object1 + its width and the x position of object2 in order to check if the right side of object 1 is touching the left side of object2.  It does this four different ways for each side of an object.  The Movement function uses a boolean value, a nested for loop, and a nested boolean to determine movement.  First boolean checks for which key of WASD has been pressed.  The for loop runs through every value in the boundaries arrays.  The second boolean checks for a collision between Zelda and the current boundary.  EX: If W is pressed and Zelda is not touching any boundary then walking will equal true and Zelda will move -movespeed on the y axis.  I used the same logic for the enemies movement, with some minor adjustments to the logic for the direction of their movement.  Since the enemies would not be controlled by WASD, I made it so that they moved in a certain direction if their enemy.(x or y)direction were true, and if they hit a boundary it would change to false, and vice versa.  I also made a movement function for keese, and had them go directly to Zelda's position, without any collision, as they are flying bats so they can fly over the trees.  For Ganon I used the same logic, but also added a function to try to randomize his movement by changing x and ydirection at random intervals.

#### For the chest interactions, I used the anycollision() function to check if Zelda collides with the chest, and if she did then the fadechest function would trigger, as the chestcheck.check variable would be set to true.

#### With the damage function I used the anycollision() function to check if Zelda collided with an enemy, if so Zeld'a health would be reduced by 1 and the healthTimer would start.  The healthTimer is a short timer to add a delay to your health loss.  Otherwise you would just die instantly once you run into an enemy.  If you run into an enemy the cf canvas will also for a short moment be set to .2 opacity and be set to red.

#### the enemies.js, misc.js, and zelda.js contain the objects that use the prototypes in class.js that represent the sprites that are used throughout.  In enemies.js, while I could use the same image as the source for the enemies, I could not create just one enemy image constant, for each enemy for some reason.  I had to create an image constant for each enemy, because if I used it multiple times, only one of the enemies would be shown, and the other would have no image.  I also manually created each enemy, and set their initial starting position mnanually.  There is probably a way to automatically create each enemy in a randomized manner, but this project is already massive, so I didn't want to take the time to figure it out.  Also, I don't reset the initial position values for the enemies in the gameover function, so on a replay, the enemies will have different starting positions than in the first playthrough.

#### I think that pretty much covers everything that I did in this project.  Overall I am proud of this project, but there are some major optimizations that I would make to it.  The biggest optimization not having the movement logic copy pasted 5 times, to account for the different boundaries on each level.  I tried to have just one movement function while working on the project, but due to my lack of understanding of functions and variables and the like, and also because of a number of bugs, I just ended up copy pasting the movement function multiple times.  I think I now have a better understanding of functions and variables, and so I think this is an optimization that I would be able to do.  Though of course, it would be no small feat.  I was able to better optimize the movement for enemies though, so I am happy about that.  Anyways, below is a link to the original Scratch game, and the link to the github repository for the remastered game, for any who are interested.  Thank you for reading and this was CS50x.


#### Scratch Link: https://scratch.mit.edu/projects/550707401/
#### Github Link: https://github.com/Yuremeshi/realzelda-jshtml.git



##### By the way I actually finished this project 10 months ago, but I didn't want to make the video so I procrastinated until now lol...